diff --git a/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts b/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts
index 256115ed59ef37edb2f84794245ec8a58cfc1ef7..9457ecf64fced9afa2d8896ca7e64075b6b73cac 100644
--- a/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts
+++ b/backend/ayanavitabackend/app/admin/src/api/productAdmin.api.ts
@@ -222,61 +222,61 @@ export async function fetchAdminProducts(): Promise<ProductAdminItem[]> {
   const languages = await fetchCatalogLanguages();
   const [products, ingredientKeys, attributeKeys] = await Promise.all([
     api<ApiProduct[]>("/catalog/products"),
     loadIngredientKeys(),
     loadAttributeKeys(),
   ]);
   return products.map((item) => mapProduct(item, languages, ingredientKeys, attributeKeys));
 }

 export async function fetchAdminProductById(id: string): Promise<ProductAdminItem | null> {
   const languages = await fetchCatalogLanguages();
   try {
     const [item, ingredientKeys, attributeKeys] = await Promise.all([
       api<ApiProduct>(`/catalog/products/${id}`),
       loadIngredientKeys(),
       loadAttributeKeys(),
     ]);
     return mapProduct(item, languages, ingredientKeys, attributeKeys);
   } catch {
     return null;
   }
 }

 export async function createAdminProduct(): Promise<ProductAdminItem> {
   const languages = await fetchCatalogLanguages();
+  const defaultName = "Sản phẩm mới";
   const payload = {
     sku: `AYA-${uid().toUpperCase()}`,
     price: 0,
     status: "draft",
     translations: languages.map((lang) => ({
       languageCode: lang.code,
-      name: "",
+      name: `${defaultName} (${lang.code.toUpperCase()})`,
       slug: `new-${lang.code}-${uid()}`,
       shortDescription: "",
       description: "",
-      guideContent: emptyGuideContent(),
     })),
   };
   const created = await api<ApiProduct>("/catalog/products", { method: "POST", body: JSON.stringify(payload) });
   return mapProduct(created, languages);
 }

 export async function updateAdminProduct(item: ProductAdminItem): Promise<ProductAdminItem> {
   const languages = await fetchCatalogLanguages();
   const product = await api<ApiProduct>(`/catalog/products/${item.id}`, {
     method: "PATCH",
     body: JSON.stringify(toProductPayload(item)),
   });

   const ingredientKeysByCode = await api<ApiIngredientKey[]>("/catalog/ingredients");
   const ingredientKeyMap = new Map(ingredientKeysByCode.map((k) => [k.code.toLowerCase(), k]));
   const ingredientItems: Array<{ ingredientKeyId: number; note: string; value: string; sortOrder: number }> = [];
   for (const [idx, ingredient] of item.ingredients.entries()) {
     const viName = ingredient.nameByLang.vi || ingredient.nameByLang.en || Object.values(ingredient.nameByLang)[0] || "";
     const code = slugify(viName || `ingredient-${idx}`);
     let key = ingredientKeyMap.get(code);
     if (!key) {
       key = await api<ApiIngredientKey>("/catalog/ingredients", {
         method: "POST",
         body: JSON.stringify({
           code,
@@ -419,39 +419,43 @@ export async function createAdminCategory(category: ProductCategory): Promise<Pr
   });
   const languages = await fetchCatalogLanguages();
   return mapCategory(created, languages);
 }

 export async function updateAdminCategory(category: ProductCategory): Promise<ProductCategory> {
   const updated = await api<ApiCategory>(`/catalog/categories/${category.id}`, {
     method: "PATCH",
     body: JSON.stringify({
       translations: category.translations.map((row) => ({
         languageCode: row.lang,
         name: row.name,
         slug: slugify(`${row.name || "category"}-${row.lang}`),
         description: row.description || "",
       })),
     }),
   });
   const languages = await fetchCatalogLanguages();
   return mapCategory(updated, languages);
 }

 export async function deleteAdminCategory(categoryId: string): Promise<void> {
   await api(`/catalog/categories/${categoryId}`, { method: "DELETE" });
 }

+export async function deleteAdminProduct(productId: string): Promise<void> {
+  await api(`/catalog/products/${productId}`, { method: "DELETE" });
+}
+
 export function upsertTranslation(
   translations: ProductTranslation[],
   lang: LanguageCode,
   patch: Partial<ProductTranslation>,
 ): ProductTranslation[] {
   const existing = translations.find((item) => item.lang === lang);
   if (!existing) {
     return [...translations, { lang, name: "", shortDescription: "", description: "", guideContent: emptyGuideContent(), ...patch }];
   }
   return translations.map((item) => (item.lang === lang ? { ...item, ...patch } : item));
 }

 export const createIngredient = (): ProductIngredient => ({ id: uid(), nameByLang: {}, note: "" });
 export const createAttribute = (): ProductAttribute => ({ id: uid(), keyByLang: {}, value: "" });
diff --git a/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx b/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx
index a5e1e24f1dbabc729e94e4be3e2ba665c0217bb5..942fd7855f5ea17f1e296acdf284d714c16bb5ad 100644
--- a/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx
+++ b/backend/ayanavitabackend/app/admin/src/pages/ProductAdminDetailPage.tsx
@@ -1,104 +1,173 @@
 import { useEffect, useMemo, useState } from "react";
 import { Link, useNavigate, useParams } from "react-router-dom";
 import {
   createAttribute,
-  deleteProductImage,
   createIngredient,
+  deleteAdminProduct,
+  deleteProductImage,
   fetchAdminCategories,
   fetchAdminProductById,
   fetchCatalogLanguages,
+  updateAdminProduct,
   updateProductImage,
   uploadProductImage,
-  updateAdminProduct,
   upsertTranslation,
 } from "../api/productAdmin.api";
 import type { AdminLanguage, ProductAdminItem, ProductCategory } from "../types/productAdmin";

+type PendingImageFileMap = Record<string, File>;
+
+const isTempImageId = (id: string) => id.startsWith("temp-");
+
 export function ProductAdminDetailPage() {
   const { productId } = useParams();
   const navigate = useNavigate();
   const [product, setProduct] = useState<ProductAdminItem | null>(null);
   const [categories, setCategories] = useState<ProductCategory[]>([]);
   const [languages, setLanguages] = useState<AdminLanguage[]>([]);
   const [activeLang, setActiveLang] = useState("vi");
   const [saving, setSaving] = useState(false);
-  const [uploadingImage, setUploadingImage] = useState(false);
+  const [pendingImageFiles, setPendingImageFiles] = useState<PendingImageFileMap>({});
+  const [deletedPersistedImageIds, setDeletedPersistedImageIds] = useState<string[]>([]);
+
+  const load = async () => {
+    if (!productId) return;
+    const langs = await fetchCatalogLanguages();
+    const [detail, categoryList] = await Promise.all([fetchAdminProductById(productId), fetchAdminCategories()]);
+    setProduct(detail);
+    setCategories(categoryList);
+    setLanguages(langs);
+    setActiveLang((prev) => (langs.find((x) => x.code === prev)?.code || langs[0]?.code || "vi"));
+    setPendingImageFiles({});
+    setDeletedPersistedImageIds([]);
+  };

   useEffect(() => {
-    const load = async () => {
-      if (!productId) return;
-      const langs = await fetchCatalogLanguages();
-      const [detail, categoryList] = await Promise.all([fetchAdminProductById(productId), fetchAdminCategories()]);
-      setProduct(detail);
-      setCategories(categoryList);
-      setLanguages(langs);
-      setActiveLang((prev) => (langs.find((x) => x.code === prev)?.code || langs[0]?.code || "vi"));
-    };
-    load();
+    void load();
   }, [productId]);

   const translation = useMemo(() => product?.translations.find((item) => item.lang === activeLang), [product, activeLang]);

-  const onSave = async () => {
-    if (!product) return;
-    setSaving(true);
-    const next = await updateAdminProduct(product);
-    setProduct(next);
-    setSaving(false);
-  };
-
-  const onUploadImage = async (file?: File | null) => {
-    if (!product || !file) return;
-    setUploadingImage(true);
-    try {
-      const uploaded = await uploadProductImage(product.id, file, product.images.length === 0, product.images.length);
-      setProduct((prev) => (prev ? { ...prev, images: [...prev.images, uploaded] } : prev));
-    } finally {
-      setUploadingImage(false);
-    }
-  };
-
-  const onPersistImage = async (imageId: string) => {
-    if (!product) return;
-    const found = product.images.find((img) => img.id === imageId);
-    if (!found) return;
-    const updated = await updateProductImage(product.id, found);
+  const updateImageDraft = (imageId: string, patch: Partial<ProductAdminItem["images"][number]>) => {
     setProduct((prev) =>
       prev
         ? {
             ...prev,
-            images: prev.images.map((img) => (img.id === imageId ? updated : img)),
+            images: prev.images.map((img) => (img.id === imageId ? { ...img, ...patch } : img)),
           }
         : prev,
     );
   };

-  const onDeleteImage = async (imageId: string) => {
+  const onAddImages = (files: FileList | null) => {
+    if (!files || !files.length) return;
+    const selectedFiles = Array.from(files);
+    const draftImages = selectedFiles.map((file, index) => ({
+      id: `temp-${Date.now()}-${index}-${Math.random().toString(36).slice(2, 8)}`,
+      imageUrl: URL.createObjectURL(file),
+      isPrimary: false,
+      sortOrder: index,
+      file,
+    }));
+
+    setProduct((prev) => {
+      if (!prev) return prev;
+      const startOrder = prev.images.length;
+      return {
+        ...prev,
+        images: [
+          ...prev.images,
+          ...draftImages.map((item, index) => ({
+            id: item.id,
+            imageUrl: item.imageUrl,
+            isPrimary: item.isPrimary,
+            sortOrder: startOrder + index,
+          })),
+        ],
+      };
+    });
+
+    setPendingImageFiles((prev) => ({
+      ...prev,
+      ...Object.fromEntries(draftImages.map((item) => [item.id, item.file])),
+    }));
+  };
+
+  const onDeleteImage = (imageId: string) => {
+    if (!product) return;
+    if (!isTempImageId(imageId)) {
+      setDeletedPersistedImageIds((prev) => (prev.includes(imageId) ? prev : [...prev, imageId]));
+    } else {
+      setPendingImageFiles((prev) => {
+        const next = { ...prev };
+        delete next[imageId];
+        return next;
+      });
+    }
+
+    setProduct({ ...product, images: product.images.filter((img) => img.id !== imageId) });
+  };
+
+  const onSave = async () => {
+    if (!product) return;
+    setSaving(true);
+    try {
+      await updateAdminProduct(product);
+
+      for (const imageId of deletedPersistedImageIds) {
+        await deleteProductImage(product.id, imageId);
+      }
+
+      for (const image of product.images) {
+        if (isTempImageId(image.id)) {
+          const file = pendingImageFiles[image.id];
+          if (!file) continue;
+          await uploadProductImage(product.id, file, image.isPrimary, image.sortOrder);
+          URL.revokeObjectURL(image.imageUrl);
+        } else {
+          await updateProductImage(product.id, image);
+        }
+      }
+
+      await load();
+    } finally {
+      setSaving(false);
+    }
+  };
+
+  const onDeleteProduct = async () => {
     if (!product) return;
-    await deleteProductImage(product.id, imageId);
-    setProduct((prev) => (prev ? { ...prev, images: prev.images.filter((img) => img.id !== imageId) } : prev));
+    if (!window.confirm("Bạn có chắc muốn xóa sản phẩm này?")) return;
+
+    try {
+      await deleteAdminProduct(product.id);
+      navigate("/catalog/products");
+    } catch (error) {
+      const message = error instanceof Error ? error.message : "Không thể xóa sản phẩm";
+      window.alert(`${message}\n\nGợi ý: nếu sản phẩm đang được tham chiếu, hãy tắt trạng thái hoạt động trước.`);
+    }
   };

   if (!product) {
     return <div className="card">Không tìm thấy sản phẩm.</div>;
   }

   return (
     <div style={{ display: "grid", gap: 14 }}>
       <div className="card">
         <div style={{ display: "flex", justifyContent: "space-between", gap: 8, alignItems: "center", flexWrap: "wrap" }}>
           <div>
             <p className="muted" style={{ margin: 0 }}>Chi tiết sản phẩm</p>
             <h2 className="h1">{translation?.name || "Sản phẩm mới"}</h2>
             <p className="muted" style={{ margin: 0 }}>{product.sku}</p>
           </div>
           <div style={{ display: "flex", gap: 8 }}>
             <button onClick={() => navigate("/catalog/products")} className="btn">Quay lại danh sách</button>
             <button onClick={onSave} className="btn btn-primary" disabled={saving}>{saving ? "Đang lưu..." : "Lưu thay đổi"}</button>
           </div>
         </div>
       </div>

       <div className="card">
         <div className="grid grid-2">
           <label>
@@ -107,61 +176,63 @@ export function ProductAdminDetailPage() {
           </label>
           <label>
             <div className="muted">Category</div>
             <select
               className="select"
               value={product.categoryId}
               onChange={(e) => setProduct((prev) => (prev ? { ...prev, categoryId: e.target.value } : prev))}
             >
               <option value="">-- Chọn category --</option>
               {categories.map((item) => (
                 <option key={item.id} value={item.id}>
                   {item.translations.find((x) => x.lang === activeLang)?.name || item.translations[0]?.name || item.id}
                 </option>
               ))}
             </select>
           </label>
           <label>
             <div className="muted">Giá</div>
             <input
               type="number"
               className="input"
               value={product.price}
               onChange={(e) => setProduct((prev) => (prev ? { ...prev, price: Number(e.target.value) } : prev))}
             />
           </label>
-          <label>
+          <div>
             <div className="muted">Trạng thái</div>
-            <select
-              className="select"
-              value={product.status}
-              onChange={(e) => setProduct((prev) => (prev ? { ...prev, status: e.target.value as "active" | "draft" } : prev))}
-            >
-              <option value="draft">draft</option>
-              <option value="active">active</option>
-            </select>
-          </label>
+            <label style={{ display: "inline-flex", gap: 8, alignItems: "center", marginTop: 10 }}>
+              <input
+                type="checkbox"
+                checked={product.status === "active"}
+                onChange={(e) =>
+                  setProduct((prev) => (prev ? { ...prev, status: e.target.checked ? "active" : "draft" } : prev))
+                }
+              />
+              {product.status === "active" ? "Đang bật" : "Đang tắt"}
+            </label>
+          </div>
         </div>
       </div>

       <div className="card">
         <div style={{ display: "flex", gap: 8, marginBottom: 10, flexWrap: "wrap" }}>
           {languages.map((lang) => (
             <button key={lang.code} onClick={() => setActiveLang(lang.code)} className={`btn ${activeLang === lang.code ? "btn-primary" : ""}`}>
               {lang.label}
             </button>
           ))}
         </div>

         <div className="grid" style={{ gap: 8 }}>
           <label>
             <div className="muted">Tên sản phẩm</div>
             <input
               className="input"
               value={translation?.name || ""}
               onChange={(e) =>
                 setProduct((prev) =>
                   prev ? { ...prev, translations: upsertTranslation(prev.translations, activeLang, { name: e.target.value }) } : prev,
                 )
               }
             />
           </label>
@@ -303,135 +374,106 @@ export function ProductAdminDetailPage() {
                         const steps = (current?.steps || [])
                           .filter((_, rowIdx) => rowIdx !== idx)
                           .map((row, orderIdx) => ({ ...row, order: orderIdx + 1 }));
                         return {
                           ...prev,
                           translations: upsertTranslation(prev.translations, activeLang, {
                             guideContent: { intro: current?.intro || "", steps },
                           }),
                         };
                       })
                     }
                   >
                     Xóa bước
                   </button>
                 </div>
               ))}
             </div>
           </div>
         </div>
       </div>

       <div className="card">
         <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", gap: 8, flexWrap: "wrap" }}>
           <h3 className="h2" style={{ margin: 0 }}>Hình ảnh sản phẩm</h3>
           <label className="btn btn-primary" style={{ cursor: "pointer" }}>
-            {uploadingImage ? "Đang tải ảnh..." : "+ Tải ảnh"}
+            + Tải nhiều ảnh
             <input
               type="file"
+              multiple
               accept="image/*"
               style={{ display: "none" }}
-              disabled={uploadingImage}
               onChange={(e) => {
-                const file = e.target.files?.[0];
-                void onUploadImage(file);
+                onAddImages(e.target.files);
                 e.currentTarget.value = "";
               }}
             />
           </label>
         </div>

         <div className="grid" style={{ gap: 10, marginTop: 10 }}>
           {product.images.length === 0 ? (
             <p className="muted" style={{ margin: 0 }}>Chưa có ảnh cho sản phẩm này.</p>
           ) : (
             product.images.map((image, idx) => (
               <div key={image.id} className="card" style={{ padding: 10 }}>
                 <div className="grid grid-2" style={{ alignItems: "start" }}>
                   <img src={image.imageUrl} alt={`Product ${idx + 1}`} style={{ width: "100%", maxHeight: 180, objectFit: "cover", borderRadius: 8 }} />
                   <div className="grid" style={{ gap: 8 }}>
                     <label>
                       <div className="muted">URL ảnh</div>
-                      <input
-                        className="input"
-                        value={image.imageUrl}
-                        onChange={(e) =>
-                          setProduct((prev) =>
-                            prev
-                              ? {
-                                  ...prev,
-                                  images: prev.images.map((row) => (row.id === image.id ? { ...row, imageUrl: e.target.value } : row)),
-                                }
-                              : prev,
-                          )
-                        }
-                      />
+                      <input className="input" value={image.imageUrl} onChange={(e) => updateImageDraft(image.id, { imageUrl: e.target.value })} />
                     </label>
                     <label>
                       <div className="muted">Thứ tự hiển thị</div>
                       <input
                         type="number"
                         min={0}
                         className="input"
                         value={image.sortOrder}
-                        onChange={(e) =>
-                          setProduct((prev) =>
-                            prev
-                              ? {
-                                  ...prev,
-                                  images: prev.images.map((row) =>
-                                    row.id === image.id ? { ...row, sortOrder: Number(e.target.value) || 0 } : row,
-                                  ),
-                                }
-                              : prev,
-                          )
-                        }
+                        onChange={(e) => updateImageDraft(image.id, { sortOrder: Number(e.target.value) || 0 })}
                       />
                     </label>
                     <label style={{ display: "flex", alignItems: "center", gap: 8 }}>
                       <input
                         type="checkbox"
                         checked={image.isPrimary}
                         onChange={(e) =>
                           setProduct((prev) =>
                             prev
                               ? {
                                   ...prev,
-                                  images: prev.images.map((row) => ({
-                                    ...row,
-                                    isPrimary: row.id === image.id ? e.target.checked : false,
-                                  })),
+                                  images: prev.images.map((row) => ({ ...row, isPrimary: row.id === image.id ? e.target.checked : false })),
                                 }
                               : prev,
                           )
                         }
                       />
                       Ảnh chính
                     </label>
                     <div style={{ display: "flex", gap: 8 }}>
-                      <button className="btn" onClick={() => void onPersistImage(image.id)}>Lưu ảnh</button>
-                      <button className="btn btn-danger" onClick={() => void onDeleteImage(image.id)}>Xóa ảnh</button>
+                      <button className="btn btn-danger" onClick={() => onDeleteImage(image.id)}>Xóa ảnh</button>
                     </div>
                   </div>
                 </div>
               </div>
             ))
           )}
         </div>
       </div>

       <div className="grid grid-2">
         <div className="card">
           <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
             <h3 className="h2">CRUD thành phần</h3>
             <button className="btn" onClick={() => setProduct((prev) => (prev ? { ...prev, ingredients: [...prev.ingredients, createIngredient()] } : prev))}>+ Thêm</button>
           </div>
           <div className="grid" style={{ marginTop: 10 }}>
             {product.ingredients.map((item) => (
               <div key={item.id} className="card" style={{ padding: 10 }}>
                 <input
                   className="input"
                   placeholder={`Tên thành phần (${activeLang})`}
                   value={item.nameByLang[activeLang] || ""}
                   onChange={(e) =>
                     setProduct((prev) =>
                       prev
@@ -513,31 +555,32 @@ export function ProductAdminDetailPage() {
                     setProduct((prev) =>
                       prev
                         ? {
                             ...prev,
                             attributes: prev.attributes.map((row) => (row.id === item.id ? { ...row, value: e.target.value } : row)),
                           }
                         : prev,
                     )
                   }
                 />
                 <button
                   className="btn btn-danger"
                   style={{ marginTop: 8 }}
                   onClick={() =>
                     setProduct((prev) => (prev ? { ...prev, attributes: prev.attributes.filter((row) => row.id !== item.id) } : prev))
                   }
                 >
                   Xóa
                 </button>
               </div>
             ))}
           </div>
         </div>
       </div>

-      <div>
+      <div style={{ display: "flex", justifyContent: "space-between", gap: 8, flexWrap: "wrap" }}>
         <Link to="/catalog/products" className="btn">← Về trang danh sách</Link>
+        <button className="btn btn-danger" onClick={() => void onDeleteProduct()}>Xóa sản phẩm</button>
       </div>
     </div>
   );
 }
diff --git a/backend/ayanavitabackend/app/api/src/catalog/products.service.ts b/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
index 8a351a2c992cf7d81413a6eb2bb9889e04de1261..4e7c7367d410ae5026b5adfcc13d3993a5a3604c 100644
--- a/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
+++ b/backend/ayanavitabackend/app/api/src/catalog/products.service.ts
@@ -1,54 +1,58 @@
-import { Injectable, NotFoundException } from '@nestjs/common'
+import { ConflictException, Injectable, NotFoundException } from '@nestjs/common'
 import { PrismaService } from '../prisma/prisma.service'
 import { CreateProductDto, UpdateProductDto } from './dto/product.dto'
 import { UpsertProductAttributesDto, UpsertProductIngredientsDto } from './dto/product-metadata.dto'
 import { normalizeBigInt } from './utils'
 import { Prisma } from '@prisma/client'
+import { ImageUploadService } from '../services/ImageUploadService'
 import { CreateProductImageDto, UpdateProductImageDto } from './dto/product-image.dto'
 type JsonValue = string | number | boolean | { [key: string]: JsonValue } | JsonValue[];

 const toProductTranslationCreateManyData = (
     productId: number,
     translations: CreateProductDto['translations'] | UpdateProductDto['translations'],
 ) =>
     (translations ?? []).map((translation) => ({
       productId: BigInt(productId),
       languageCode: translation.languageCode,
       name: translation.name,
       slug: translation.slug,
       shortDescription: translation.shortDescription,
       description: translation.description,
       guideContent: translation.guideContent
           ? (JSON.parse(JSON.stringify(translation.guideContent)) as JsonValue)
           : null,

     }))

 @Injectable()
 export class ProductsService {
-  constructor(private readonly prisma: PrismaService) {}
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly imageUploadService: ImageUploadService,
+  ) {}

   async findAll() {
     const rows = await this.prisma.catalogProduct.findMany({
       include: { translations: true, category: true, images: { orderBy: { sortOrder: 'asc' } } },
       orderBy: { id: 'desc' },
     })
     return normalizeBigInt(rows)
   }

   async findOne(id: number) {
     const row = await this.prisma.catalogProduct.findUnique({
       where: { id: BigInt(id) },
       include: {
         translations: true,
         category: true,
         attributes: true,
         ingredients: true,
         images: { orderBy: [{ isPrimary: 'desc' }, { sortOrder: 'asc' }, { id: 'asc' }] },
       },
     })
     if (!row) throw new NotFoundException('Product not found')
     return normalizeBigInt(row)
   }

   async create(dto: CreateProductDto) {
@@ -118,52 +122,70 @@ export class ProductsService {
     return normalizeBigInt(rows)
   }

   async replaceIngredients(id: number, dto: UpsertProductIngredientsDto) {
     await this.findOne(id)
     const rows = await this.prisma.$transaction(async (tx) => {
       await tx.productIngredient.deleteMany({ where: { productId: BigInt(id) } })
       if (dto.items.length) {
         await tx.productIngredient.createMany({
           data: dto.items.map((item) => ({
             productId: BigInt(id),
             ingredientKeyId: BigInt(item.ingredientKeyId),
             value: item.value,
             note: item.note,
             sortOrder: item.sortOrder ?? 0,
           })),
         })
       }
       return tx.productIngredient.findMany({ where: { productId: BigInt(id) }, orderBy: { sortOrder: 'asc' } })
     })
     return normalizeBigInt(rows)
   }

   async remove(id: number) {
     await this.findOne(id)
-    const row = await this.prisma.catalogProduct.delete({ where: { id: BigInt(id) } })
-    return normalizeBigInt(row)
+
+    try {
+      const row = await this.prisma.$transaction(async (tx) => {
+        const images = await tx.productImage.findMany({ where: { productId: BigInt(id) } })
+
+        for (const image of images) {
+          await this.imageUploadService.deleteImage({ url: image.imageUrl })
+        }
+
+        await tx.productImage.deleteMany({ where: { productId: BigInt(id) } })
+        return tx.catalogProduct.delete({ where: { id: BigInt(id) } })
+      })
+
+      return normalizeBigInt(row)
+    } catch (error) {
+      if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
+        throw new ConflictException('Không thể xóa sản phẩm do đang được tham chiếu dữ liệu khác. Vui lòng tắt trạng thái hoạt động trước.')
+      }
+      throw error
+    }
   }

   async listImages(id: number) {
     await this.findOne(id)
     const rows = await this.prisma.productImage.findMany({
       where: { productId: BigInt(id) },
       orderBy: [{ isPrimary: 'desc' }, { sortOrder: 'asc' }, { id: 'asc' }],
     })
     return normalizeBigInt(rows)
   }

   async createImage(id: number, dto: CreateProductImageDto) {
     await this.findOne(id)
     const created = await this.prisma.productImage.create({
       data: {
         productId: BigInt(id),
         imageUrl: dto.imageUrl,
         isPrimary: dto.isPrimary ?? false,
         sortOrder: dto.sortOrder ?? 0,
       },
     })
     return normalizeBigInt(created)
   }

   async updateImage(id: number, imageId: number, dto: UpdateProductImageDto) {
